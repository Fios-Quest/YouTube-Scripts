<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Iterators - IRISS Scripts</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">IRISS Scripts</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<p>I've been foreshadowing it for a while, but today we finally cover Iterators!</p>
<p>Iterators are a way to produce, and perform operations on, a sequence of values.</p>
<p>We often use them with collections (which we covered in our last video) so that we can perform the same operation on
each item in a collection, or reduce a collection to a single value.</p>
<p>They're also often used implicitly in some forms of loop.</p>
<p>As ever, this series is accompanied by a free book, check the description for a link straight to this chapter.</p>
<p>My name is Daniel, welcome to iris.</p>
<h2 id="the-iterator-trait"><a class="header" href="#the-iterator-trait">The Iterator Trait</a></h2>
<p>The Iterator trait can be applied to any type and has a single required method:</p>
<p><img src="014-iterators/iter-rust-doc.png" alt="iter-rust-doc.png" /></p>
<p>ðŸ“• <code>.next()</code> returns an <code>Option</code> telling the caller there either is another item (Some), or there isn't (None).</p>
<p>ðŸ“• Iterator also has 75 provided methods, which I think goes to show how incredibly versatile this trait is.</p>
<p>ðŸ“• We'll be talking about some of these methods, but it's well worth checking out the documentation to see what else is
possible.</p>
<p>While you'll usually get iterators from things like collections, it's possible to "Iterate" through anything.</p>
<p>To show the power of Iterators, we're going to start by building an Iterator from scratch, one that produces the
Fibonacci sequence.</p>
<p>The Fibonacci sequence is a sequence of numbers where each number is the sum of the previous two.</p>
<p>Depending on whom you ask, the sequence either starts, <code>1, 2</code>, <code>1, 1</code>, or <code>0, 1</code>.</p>
<p>Purists will say it's the former (as "Leonardo Bonacci" intended), software engineers usually use the latter... I'm
sticking mine in the middle, but it really doesn't matter.</p>
<p>ðŸ¦€ Anyway, let's start by making a Struct to store the state of the Iterator.</p>
<p><img src="014-iterators/fib-base.png" alt="fib-base.png" /></p>
<p>ðŸ¦€ We'll need to know the previous number and the next number, and to keep it simple we'll use a <code>u8</code> so we'll only get
numbers between zero and two-five-five.</p>
<p>ðŸ¦€ I've chosen to make next an option for reasons you'll see in a moment</p>
<p>ðŸ¦€ Let's make a constructor so that the Iterator always starts in a valid state.</p>
<p>ðŸ¦€ Moving on to implementing Iterator itself.</p>
<p><img src="014-iterators/fib-impl-iterator.png" alt="fib-impl-iterator.png" /></p>
<p>ðŸ¦€ The trait has an associated type <code>Item</code> that describes the type returned by each call of <code>.next()</code> on the iterator.</p>
<p>ðŸ¦€ It's an associated type rather than a generic type as it needs to be referenced a <em>lot</em> but, it's type is dictated by
the process used to create the Iterator, so it isn't generic.</p>
<p>ðŸ¦€ To implement the <code>next</code> method, we'll temporarily store the current value of the value <code>next</code>.</p>
<p>ðŸ¦€ Because <code>self.next</code> is an Option, and the <code>next</code> method returns an Option, we can use the question mark operator
to either unwrap a <code>Some</code> variant, or immediate return a <code>None</code> variant depending on what's in there.</p>
<p>ðŸ¦€ If there is a <code>None</code> at this point, then we've reached the end of our sequence.</p>
<p>ðŸ¦€ Next we'll update our internal state, our new next is the current value plus the previous, and our previous becomes
the old current.</p>
<p>ðŸ¦€ By using <code>checked_add</code> here we get an <code>Option</code> that is <code>None</code> if the result is out of bounds.</p>
<p>ðŸ¦€ Finally, we return the stored "current" value, though we'll have to re-wrap it in an Option after unwrapping it
earlier.</p>
<p>ðŸ¦€ So now we have our iterator type!</p>
<p><img src="014-iterators/fib-next-next-next.png" alt="fib-next-next-next.png" /></p>
<p>ðŸ¦€ We can now get each item off the iterator one at a time by calling the next function:</p>
<p>ðŸ¦€ You can see that each item in the sequence is wrapped in an <code>Option</code>.</p>
<p>ðŸ¦€ When an Iterator has no more items to provide, it will produce a <code>None</code>.</p>
<p>ðŸ¦€ The final number this Iterator will produce is <code>233</code>, after which we would overflow the <code>u8</code> we've used.</p>
<p>ðŸ¦€ Just calling <code>.next()</code> is pretty boring, no one wants to iterate through things by hand.</p>
<p>ðŸ¦€ What if we want to print out all the Fibonacci values that fit inside a <code>u8</code>?</p>
<p><img src="014-iterators/fib-for-in.png" alt="fib-for-in.png" /></p>
<p>ðŸ¦€ You can give an Iterator to a <code>for ... in ...</code> loop, and it will automatically unwrap the <code>Option</code> for you.</p>
<p>ðŸ¦€ This code will print out each number on a new line</p>
<p>ðŸ¦€ Once the loop hits a <code>None</code> the loop ends.</p>
<p>That's cool, but on its own, it's still not very interesting.</p>
<p>Iterators are designed to be chained.</p>
<p>Those 75 provided methods I mentioned earlier allow you to do some exceptional tricks.</p>
<p>ðŸ¦€ For example, a list of Fibonacci numbers might be more useful if we knew what number in the sequence we're on.</p>
<p><img src="014-iterators/fib-for-in-enumerate.png" alt="fib-for-in-enumerate.png" /></p>
<p>ðŸ¦€ We can chain a method called <code>.enumerate</code> which will take the old iterator and give us a new one where each <code>next</code> now
returns a tuple of <code>(usize, T)</code> where the <code>T</code> is the original item and the <code>usize</code> is the position.</p>
<p>ðŸ¦€ What's brilliant about this though is that when I say it "takes the old iterator", it doesn't try to process every
item in the iterator (a process in Rust we refer to as "consuming" the iterator), it merely takes ownership of it.</p>
<p>ðŸ¦€ When we call <code>.next()</code> on the iterator returned by <code>.enumerate()</code>, <em>it</em> calls next on the iterator being enumerated.</p>
<p>Rust iterators are "lazy" meaning that they try to avoid doing any unnecessary work.</p>
<h2 id="getting-iterators"><a class="header" href="#getting-iterators">Getting Iterators</a></h2>
<p>Having built our own, hopefully you now have a <em>vague</em> understanding of how Iterators work, but usually you'll get an
Iterator from a collection.</p>
<p>As with most things in Rust, Iterators (or specifically, the items being iterated) can be thought of in three groups.</p>
<p>All the collections we discussed in the last video can give you an iterator in any of the following forms.</p>
<p>Firstly, referenced data</p>
<p>Often we don't need to <em>own</em> the data we're iterating over, it can be enough to just read it.</p>
<p>All built in collections have a method called <code>.iter()</code> which returns an Iterator type where the items are references to
the data held in the collection.</p>
<p>ðŸ¦€ Here we have two variables that <em>own</em> the Strings inside them.</p>
<p><img src="014-iterators/iter-iter.png" alt="iter-iter.png" /></p>
<p>ðŸ¦€ We move ownership of the variables inside the Vector</p>
<p>ðŸ¦€ And then we create an Iterator with the Iter method which will iterate over references that point to the data now
owned by the vector</p>
<p>ðŸ¦€ So calling <code>.next()</code> on the iterator gives us a reference, not the original data.</p>
<p>ðŸ¦€ This means the vector still owns the data</p>
<p>ðŸ¦€ One thing to bear in mind is that if the collection contains references, then <code>.iter()</code> will give you an Iterator that
produces references to references.</p>
<p><img src="014-iterators/iter-iter-ref.png" alt="iter-iter-ref.png" /></p>
<p>ðŸ¦€ So if we change the original vector to reference the Strings rather than take ownership</p>
<p>ðŸ¦€ When we call <code>.next()</code> we get a reference to a reference</p>
<p>Sometimes, you need to edit things while iterating through them; our second option lets us do that.</p>
<p><code>.iter_mut()</code> can give you a mutable iterator, and all of Rust's built-in collections support it (so long as the
underlying collection is mutable).</p>
<p>ðŸ¦€ In this example, we'll use a Vector of numbers, as I mentioned, we need this Vector to be mutable.</p>
<p><img src="014-iterators/iter-iter-mut.png" alt="iter-iter-mut.png" /></p>
<p>ðŸ¦€ We'll use a for ... in ... loop like earlier, using <code>.iter_mut()</code>.</p>
<p>ðŸ¦€ So here, n, is a mutable reference to the value stored in the vector.</p>
<p>ðŸ¦€ By dereferencing n, we can add 10 to the original value.</p>
<p>ðŸ¦€ If we check the original Vector now, we can see all values have increased by 10.</p>
<p>Finally, you may want to take ownership of the underlying data, and that's where our third option comes in.</p>
<p><code>.into_iter()</code> takes ownership of the collection and the data inside (meaning that the collection will no longer be available).</p>
<p>One place this is particularly useful is when converting between types, either converting the items themselves or for the entire collection.</p>
<p>There is a trait called <code>FromIterator&lt;A&gt;</code> that is implemented for types that can consume an iterator and populate themselves.</p>
<p>This is almost always used with the <code>.collect()</code> iterator method, though you need to be explicit about what you're collecting into.</p>
<p>You can do this either by typing the variable you're collecting into, or by using the turbofish operator that allows you to be explicit about the concrete types to fill in generics.</p>
<p>ðŸ¦€ In this example, we'll go back to our Strings as they aren't <code>Copy</code>.</p>
<p><img src="014-iterators/iter-into-iter.png" alt="iter-into-iter.png" /></p>
<p>ðŸ¦€ Instead of using a Vector this time, we'll use a LinkedList, and push our strings onto the end.</p>
<p>ðŸ¦€ This moves ownership from the variables into the LinkedList.</p>
<p>ðŸ¦€ To turn the LinkedList into a Vector, we'll first convert the LinkedList into an Iterator that owns the original data with <code>.into_iter()</code>.</p>
<p>ðŸ¦€ Then we'll "collect" that Iterator into a Vector.</p>
<p>ðŸ¦€ Because <code>v</code> is explicitly typed, Rust knows to use the <code>FromIterator</code> implementation of <code>Vector</code> when calling <code>.collect()</code>.</p>
<p>Honestly, even after years of using Rust, this backwards way of writing code that makes it super modular still makes me think: "wow"</p>
<p>ðŸ¦€ In this example, we've created a variable <em>basically</em> just to provide type information.</p>
<p><img src="014-iterators/iter-into-iter-turbofish.png" alt="iter-into-iter-turbofish.png" /></p>
<p>ðŸ¦€ You can skip this step using the turbofish operator which looks like this.</p>
<h2 id="copying-and-cloning-items"><a class="header" href="#copying-and-cloning-items">Copying and cloning Items</a></h2>
<p>Using what we've learned above, what if we want to use owned data, but we need to keep the original collection, so <code>.into_iter()</code> is out of the question?</p>
<p>There are two methods on <code>Iterator</code> for this purpose: <code>.copied()</code> and <code>.cloned()</code>.</p>
<p>Each one takes the old iterator and returns a new iterator that applies the appropriate action lazily as its called.</p>
<p><code>.copied()</code> only works on Iterators where the item is <code>Copy</code> and will take the iterator and return a new iterator which returns each Item copied.</p>
<p><img src="014-iterators/copied.png" alt="copied.png" /></p>
<p><code>.cloned()</code> does the same for types that are <code>Clone</code>.</p>
<p><img src="014-iterators/cloned.png" alt="cloned.png" /></p>
<h2 id="other-ways-to-get-iterators"><a class="header" href="#other-ways-to-get-iterators">Other Ways to get Iterators</a></h2>
<p>Beyond collections, there are other things that can be iterated through.</p>
<p>ðŸ¦€ Ranges <em>are</em> iterators, it's why you often see them used in for loops:</p>
<p><img src="014-iterators/other-iter-range.png" alt="other-iter-range.png" /></p>
<p>ðŸ¦€ But they implement all the same methods so we can collect them like any other iterator.</p>
<p>ðŸ¦€ You can make an infinitely repeating iterator of anything so long as it implements <code>Clone</code>, using <code>std::iter::repeat</code>.</p>
<p><img src="014-iterators/other-iter-repeat.png" alt="other-iter-repeat.png" /></p>
<p>ðŸ¦€ Now, because immutable references implement <code>Clone</code> we could use this function to repeat a reference to string slice like "hi".</p>
<p>// FIXME</p>
<p>ðŸ¦€ Um, I said "hi".</p>
<p>ðŸ¦€ Wait!</p>
<p>ðŸ¦€ It literally never ends, every time you call <code>.next()</code> it just clones a new value</p>
<p>ðŸ¦€ Ok enough of that.</p>
<p>ðŸ¦€ We can also repeat existing iterators infinitely using a method on the iterator called <code>.cycle()</code></p>
<p><img src="014-iterators/other-iter-cycle.png" alt="other-iter-cycle.png" /></p>
<p>ðŸ¦€ Once the iterator has run out of items, instead of returning a <code>None</code>, it simply starts again.</p>
<p>You can also create iterators by combining other iterators with <code>.chain()</code>, although they have to be of the same type:</p>
<p><img src="014-iterators/other-iter-chain.png" alt="other-iter-chain.png" /></p>
<p>Many other Types in Rust can also be broken down into Iterators.</p>
<p>The script for this video, for example, can be represented as one large <code>str</code>, which you can break the data down by <code>.lines()</code>, <code>.chars()</code> or <code>.bytes()</code> all of which produce iterators.</p>
<h2 id="cool-ways-to-use-iterators"><a class="header" href="#cool-ways-to-use-iterators">Cool ways to use Iterators</a></h2>
<h3 id="mathematics"><a class="header" href="#mathematics">Mathematics</a></h3>
<p>One common thing we might want to do is consume an iterator of numeric values and get some new value from it.</p>
<p>A quick warning though!</p>
<p>Unlike some other operations we might perform on iterators which add some step that <em>will</em> be performed when we call <code>.next</code>, methods that "consume" the Iterator will actually try to process everything in the Iterator.</p>
<p>This means if you call them on an infinite iterator, like those created by <code>.repeat()</code> or <code>.cycle()</code>, your code will enter an infinite loop and never end.</p>
<p>However, when that's not the case there's some useful mechanisms we can use:</p>
<p>ðŸ¦€ For iterators of items that implement the <code>Sum</code> trait (for example numbers) the <code>.sum()</code> method will add all the items in the iterator together:</p>
<p><img src="014-iterators/maths-sum.png" alt="maths-sum.png" /></p>
<p>ðŸ¦€ You'll notice we have the turbofish operator again as we need to know what type to sum to</p>
<p>ðŸ¦€ For iterators of items that implement the <code>Product</code> trait (eg, again, numbers) the <code>.product()</code> method will multiply all the items in the iterator together:</p>
<p><img src="014-iterators/maths-product.png" alt="maths-product.png" /></p>
<p>ðŸ¦€ Its worth noting that some surprising things implement <code>Sum</code> and <code>Product</code>, including blanket implementations for <code>Option&lt;T&gt;</code> and <code>Result&lt;T, E&gt;</code> where <code>T</code> already implements the trait.</p>
<p><img src="014-iterators/maths-sum-option.png" alt="maths-sum-option.png" /></p>
<p>ðŸ¦€ When doing it this way, for some reason, the Option <em>needs</em> to be owned, so here we've <code>.into_iter()</code>'d the collection, as we don't need to use the collection afterward.</p>
<p>ðŸ¦€ Or, if we do need to keep the collection, because i32 is Copy, we could chain <code>.iter()</code> with <code>.copied()</code></p>
<p><img src="014-iterators/maths-sum-option-copied.png" alt="maths-sum-option-copied.png" /></p>
<p>ðŸ¦€ I want to add another quick warning here, <code>.sum()</code> and <code>.product()</code> use the basic <code>add</code> and <code>multiply</code> operators respectively.</p>
<p>ðŸ¦€ This can be problematic because there's no check to see if the result still fits inside the numeric type.</p>
<p>ðŸ¦€ For example, this is fine</p>
<p><img src="014-iterators/maths-product-safe.png" alt="maths-product-safe.png" /></p>
<p>// FIXME</p>
<p>ðŸ¦€ But this will panic</p>
<p><img src="014-iterators/maths-product-panic.png" alt="maths-product-panic.png" /></p>
<p>ðŸ¦€ But you won't know that until runtime.</p>
<p>ðŸ¦€ Usually this won't be a problem as you'll likely be using number types with a lot of space, not <code>u8</code>s, but we'll touch on slower (but safer) ways to get around this later.</p>
<p>ðŸ¦€ Anyway, carrying on:</p>
<p>ðŸ¦€ For iterators of items that implement <code>Ord</code> you can use <code>.min()</code> and <code>.max()</code> to find the smallest and largest values respectively.</p>
<p><img src="014-iterators/maths-min-max.png" alt="maths-min-max.png" /></p>
<p>ðŸ¦€ Chars are ordered by their numeric value so capitals come first, making "H" the smallest value and "w" the "largest" value</p>
<p>ðŸ¦€ If you just want to know how many items there are, you can use <code>.count()</code> which merely tells us how many items are in an iterator.</p>
<p><img src="014-iterators/maths-count.png" alt="maths-count.png" /></p>
<p>ðŸ¦€ However, count consumes iterator, meaning you can't use the iterator after using count</p>
<p>ðŸ¦€ If the iterator implements <code>ExactSizeIterator</code> though, and many iterators do, then you can use <code>.len()</code> instead.</p>
<p><img src="014-iterators/maths-len.png" alt="maths-count.png" /></p>
<p>ðŸ¦€ Not only does this not consume the iterator, it's almost always faster to get the same result:</p>
<h3 id="applying-a-process-over-each-item"><a class="header" href="#applying-a-process-over-each-item">Applying a Process over each item</a></h3>
<p>One of the most common uses for Iterators is to process a set of Items one at a time.</p>
<p>There are a number of methods on the Iterator trait (that themselves return new Iterators) that are really helpful for this.</p>
<p>In fact, it's common to chain multiple iterators together in this way.</p>
<p>Let's start with one of the simplest.</p>
<p>You can take an iterator and exclude Items based on the result of a predicate using <code>.filter()</code>.</p>
<p>ðŸ¦€ For example, we could take a range of numbers, and filter out all odd numbers like this:</p>
<p><img src="014-iterators/process-filter-range.png" alt="process-filter-range.png" /></p>
<p>ðŸ¦€ If we were to look at the count of the iterators before and after the filter, you'll see they've changed!</p>
<p>ðŸ¦€ Now, I was going to point out that ideally we should use <code>.len()</code> but that <code>.filter()</code> can not return an <code>ExactSizeIterator</code>.</p>
<p><img src="014-iterators/process-filter-range-inclusive.png" alt="process-filter-range-inclusive.png" /></p>
<p>ðŸ¦€ But, to my surprise, <code>ExactSizeIterator</code> isn't implemented for <code>RangeInclusive</code> either... but it is for <code>Range</code>.</p>
<p>ðŸ¦€ So, here's a quick edit to the code that does the same thing.</p>
<p>ðŸ¦€ Now we can use <code>.len()</code> on the range, much better</p>
<p>ðŸ¦€ I don't know why <code>RangeInclusive</code> isn't <code>ExactSizeIterator</code>, if you do, let me know in the comments, but I think it's a sign to prefer <code>Range</code> over <code>RangeInclusive</code>.</p>
<p>ðŸ¦€ Anyway, for the obvious reasons we don't know if an Item is included or not before an item is processed by the filter, so we don't get an <code>ExactSizeIterator</code> back from the <code>.filter()</code> method, so we have to count each item.</p>
<p>Another great way to process Iterators one Item at a time is to take that Item and transform it in some way.</p>
<p>We can pass a function into the <code>.map()</code> method that receives the item and returns a new value.</p>
<p>If that value is of a different type, the Iterator you get back will also be of that new type:</p>
<p>ðŸ¦€ If we start off with a Range like this, this is an Iterator where the Item is of type <code>i32</code>.</p>
<p><img src="014-iterators/process-map.png" alt="process-map.png" /></p>
<p>ðŸ¦€ We can then use <code>.map()</code> to take the number and return the result of the format macro.</p>
<p>ðŸ¦€ And now we have an Iterator where the Item is of type <code>String</code>.</p>
<p>ðŸ¦€ Sometimes the process you apply to an item might itself result in an <code>Option</code>, and rather than having an iterator of <code>Options</code> you may want to discard <code>None</code>s and unwrap <code>Ok</code>s, this is where <code>.filter_map()</code> is really handy.</p>
<p><img src="014-iterators/process-filter-map.png" alt="process-filter-map.png" /></p>
<p>ðŸ¦€ This range gives us every valid <code>u8</code> number in sequence from smallest, zero, to largest, two-five-five</p>
<p>ðŸ¦€ (Despite what we just discussed this time it has to be <code>RangeInclusive</code>).</p>
<p>ðŸ¦€ If we add 250 to each number, most of them will no longer fit inside a <code>u8</code>.</p>
<p>ðŸ¦€ The <code>.checked_add()</code> method found on most numeric types in Rust will return an Option, where the <code>None</code> variant represents an overflow.</p>
<p>ðŸ¦€ If we combine this with a <code>.filter_map()</code> all numbers that overflow will automatically be excluded (because of the <code>None</code>) and all numbers in the <code>Some</code> variant are automatically unwrapped</p>
<p>ðŸ¦€ That leaves us with these six numbers.</p>
<p>ðŸ¦€ This not only saves us from having to deal with doubly wrapped options from <code>next</code> (for example <code>Some(Some(255))</code>) but entirely removes the items from the iterator meaning anything else we chain doesn't have to deal with it either.</p>
<p>ðŸ¦€ By comparison, if we just used a map, we'd have 256 Options, 250 of which are <code>None</code>.</p>
<p><img src="014-iterators/process-filter-map-count.png" alt="process-filter-map-count.png" /></p>
<p>ðŸ¦€ Another way to reduce how many items we want to deal with in an iterator is by using <code>.take(n)</code> and <code>.skip(n)</code>.</p>
<p><img src="014-iterators/process-take-skip.png" alt="process-take-skip.png" /></p>
<p>ðŸ¦€ We can end an iterator earlier by only taking a certain number of items from it with <code>.take(n)</code></p>
<p>ðŸ¦€ Or we can skip over a number of items with <code>.skip(n)</code> before resuming the iterator from that point.</p>
<p>ðŸ¦€ <code>.take()</code> can be particularly useful when working with infinite iterators</p>
<p><img src="014-iterators/process-repeat-take-cycle.png" alt="process-repeat-take-cycle.png" /></p>
<p>ðŸ¦€ I want you to consider the output of the following program.</p>
<p>ðŸ¦€ Consider it!</p>
<p>ðŸ¦€ <em>cough cough</em></p>
<p>ðŸ¦€ An Iterator method we used earlier, <code>.enumerate()</code>, allows us to add an index to our Iterator by changing the type of the Item <code>T</code> to a tuple of <code>(usize, T)</code>.</p>
<p>ðŸ¦€ This can be really handy in combination with other iterators when the position in an iterator is important.</p>
<p>ðŸ¦€ Let's say we want to filter every other item out of a <code>Vec</code>.</p>
<p><img src="014-iterators/process-enumerate.png" alt="process-enumerate.png" /></p>
<p>ðŸ¦€ We can do that by chaining together several of the Iterators we've just learned.</p>
<p>ðŸ¦€ We'll take ownership of the data because we don't need the original Vector after this.</p>
<p>ðŸ¦€ We'll enumerate the iterator so we get the index from the point we're at in the iterator onwards (here we're at the start, but that might not always be the case)</p>
<p>ðŸ¦€ The index starts at zero, so by checking the modulo of the index, we can take every other item starting with the first.</p>
<p>ðŸ¦€ Filter doesn't change the data only decides if it should be kept or not, this means we can ignore the original data inside the predicate</p>
<p>ðŸ¦€ Since we no longer need the index after this, we can map the tuple and return just the data we care about</p>
<p>ðŸ¦€ Finally, we'll collect it and test the result</p>
<p>ðŸ¦€ Any time you see a <code>filter</code> and a <code>map</code> next to each other though, you might be able to abbreviate your code with <code>filter_map</code>.</p>
<p>ðŸ¦€ Booleans can be turned into <code>Option</code>s with <code>.then_some()</code>, so this works, but...</p>
<p><img src="014-iterators/process-enumerate-filtermap.png" alt="process-enumerate-filtermap.png" /></p>
<p>ðŸ¦€ in my opinion, you should always go with the code that's easiest to read, and its up to you to decide what that is</p>
<p>Finally, there are three more consuming methods I want to cover for processing data</p>
<p><code>.fold()</code> and <code>.reduce()</code> consume iterators and return a single value by modifying that value for each item in the Iterator.</p>
<p><code>.fold()</code> lets you specify the initial value for the returned value, but <code>.reduce()</code> uses the first item in the iterator as the initial value and continues processing from the next item.</p>
<p>Earlier I mentioned some risk with <code>.sum()</code> and <code>.product()</code> and promised a slower but safer way to do the same thing.</p>
<p>ðŸ¦€ So let's try doing that with <code>.fold()</code></p>
<p><img src="014-iterators/process-fold.png" alt="process-fold.png" /></p>
<p>ðŸ¦€ it takes two parameters, the first being the initial value, and the second being a closure with two parameters</p>
<p>ðŸ¦€ We'll use an Option with a 0 for the initial value, which is why we can't use <code>.reduce()</code> in this specific case.</p>
<p>ðŸ¦€ For the closure, I usually stick to calling the parameters <code>acc</code> and <code>cur</code> representing the "acc-umulated" value which starts as our initial value, and the "cur-rent" value, which is the current Item in the iterator.</p>
<p>ðŸ¦€ This closure is called for every Item in the iterator and returns the <em>next</em> accumulated value.</p>
<p>ðŸ¦€ We're simply going to add the values together, our accumulated value is an Option, and we only need to add if it's a <code>Some</code> variant</p>
<p>ðŸ¦€ We can use <code>.and_then()</code> to get inside the Option, and we'll use the same <code>checked_add</code> to increase the value</p>
<p>ðŸ¦€ This maps our Option to another Option that comes out of <code>checked_add</code> so we don't need to do anything else before returning from the closure</p>
<p>ðŸ¦€ That said, there's actually a better way to provide this functionality.</p>
<p>ðŸ¦€ The way we've built this, once we hit our first <code>None</code>, we <em>know</em> the answer is going to be <code>None</code> too, yet we keep processes items</p>
<p>ðŸ¦€ There's a method designed exactly for this, <code>.try_fold()</code></p>
<p><img src="014-iterators/process-try-fold.png" alt="process-try-fold.png" /></p>
<p>ðŸ¦€ Not only will stop iterating on it's first <code>None</code>, potentially ending very early, but because it knows we're dealing with <code>Option</code>s will automatically unwrap our accumulated option for us, making the code much simpler!</p>
<p>ðŸ¦€ The last consumer method I wanted to talk about is <code>.for_each()</code>.</p>
<p>ðŸ¦€ It lets you do something with each item in the iterator without returning anything.</p>
<p>ðŸ¦€ The simplest example might be, if we went back to our Fibonacci sequence instead of printing the value in a loop, we can use <code>.for_each()</code> to print the value.</p>
<p><img src="014-iterators/process-try-fold.png" alt="process-try-fold.png" /></p>
<p>ðŸ¦€ The lack of return value might <em>feel</em> like it rather limits the usefulness of this method.</p>
<p>ðŸ¦€ However, it can be useful when doing things like sending data somewhere else, for example, across threads, which we'll be looking at in the next video.</p>
<h2 id="more-iterator-traits"><a class="header" href="#more-iterator-traits">More Iterator Traits</a></h2>
<p>There are a few more traits you may want to be aware of when making your own iterators, or consuming others.</p>
<p><code>IntoIterator</code> can be implemented on any type that can be turned into. an... <code>Iterator</code>.</p>
<p>Ah, I see what they did there.</p>
<p>One place you may find yourself using it is on newtypes, or types where the most important data inside is represented as some kind of collection.</p>
<p>ðŸ¦€ Let's say we have a newtype "Albums", that contains a Vector of "Album"</p>
<p><img src="014-iterators/albums.png" alt="albums.png" /></p>
<p>ðŸ¦€ In our domain logic, it might make sense that we can start a new collection of Albums and add an Album to it by buying it.</p>
<p>ðŸ¦€ So we can build an Albums struct like this</p>
<p><img src="014-iterators/albums-new.png" alt="albums-new.png" /></p>
<p>ðŸ¦€ If we were to implement <code>IntoIterator</code> for <code>Albums</code> there are two important associated types that we need to specify.</p>
<p><img src="014-iterators/albums-into-iterator.png" alt="albums-into-iterator.png" /></p>
<p>ðŸ¦€ <code>Item</code> is easy, that'll be our <code>Album</code> type.</p>
<p>ðŸ¦€ <code>IntoIter</code> is the name of the type that <em>is</em> the Iterator.</p>
<p>ðŸ¦€ Remember back at the start, we created a Fibonacci Iterator.</p>
<p>ðŸ¦€ Our struct <code>Fibonacci</code> is the Iterator type.</p>
<p>ðŸ¦€ What the trait is actually asking us for here is the data type that will manage the iteration process for us.</p>
<p>ðŸ¦€ We're using a Vec internally, and Vec has a generic Iterator struct it uses when you turn a Vec into an Iterator, so we can use that, filling in the Generic part with our Item type.</p>
<p>ðŸ¦€ All we need to do in our case then, is return the result of calling Vec <code>.into_iter()</code></p>
<p>ðŸ¦€ Once we've done that, turning our Albums type into an Iterator of Album is trivial.</p>
<p><img src="014-iterators/albums-to-artists.png" alt="albums-to-artists.png" /></p>
<p>ðŸ¦€ This code turns our Albums collection into a list of Artists</p>
<p>ðŸ¦€ But what if we want to go back to having our Albums type again.</p>
<p>ðŸ¦€ <code>FromIterator</code> allows you to turn an Iterator into another type, usually through the <code>.collect()</code> method on an <code>Iterator</code></p>
<p>ðŸ¦€ In our case, again, we could really just lean into the existing Vec type's utilities,</p>
<p><img src="014-iterators/albums-from-iterator-manual.png" alt="albums-from-iterator-manual.png" /></p>
<p>ðŸ¦€ But you could also rely on the structs own implementation to do the same thing by looping through the iterator.</p>
<p><img src="014-iterators/albums-from-iterator-vec.png" alt="albums-from-iterator-vec.png" /></p>
<p>ðŸ¦€ Now we can create our Albums struct from any Iterator of Album</p>
<p><img src="014-iterators/albums-vec-to-albums-struct.png" alt="albums-vec-to-albums-struct.png" /></p>
<p>Finally, the last two traits you should be aware of are <code>DoubleEndedIterator</code> and <code>ExactSizeIterator</code>.</p>
<p>We could implement these for our Album type, but we'd really just be wrapping Vec, so I'll give some more direct examples.</p>
<p>ðŸ¦€ We've spoken about <code>ExactSizeIterator</code>, it can tell you the size of the iterator <em>without</em> consuming it, using the <code>.len()</code> method</p>
<p><img src="014-iterators/other-traits.png" alt="other-traits.png" /></p>
<p>ðŸ¦€ <code>DoubleEndedIterator</code> allows you to reverse the order of an Iterator with <code>.rev()</code>.</p>
<p>ðŸ¦€ The Iterators returned from all collections in the standard library are all, both of these</p>
<p>ðŸ¦€ To my surprise, even the <code>Iter</code> structs used for <code>LinkedList</code> and <code>BinaryHeap</code> are both <code>DoubleEndedIterator</code>, I didn't expect that.</p>
<p><img src="014-iterators/other-traits-ll.png" alt="other-traits-ll.png" /></p>
<h2 id="next-time"><a class="header" href="#next-time">Next Time</a></h2>
<p>First, I want to say a huge thank-you to my Patreons, your support for the channel so early on really helps!</p>
<p>And if you enjoyed the video, don't forget to like and subscribe, you'd be surprised how much of a positive impact that has for creators!</p>
<p>We've now covered all of what I'd describe as the core, synchronous language features (at least... I hope, let me know if you think I've missed something crucial).</p>
<p>We're moving on to Threads in the next video, we'll discuss what they are, why you'd use them, and some of the most important and useful tools to use when working with them.</p>
<p>With that, I'll see you next time.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../iriss/013-collections.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../channel-news/001-fios-quest.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../iriss/013-collections.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../channel-news/001-fios-quest.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
